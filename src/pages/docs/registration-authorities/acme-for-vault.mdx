---
title: ACME Registration Authority for Hashicorp Vault CA
html_title: ACME Registration Authority for Hashicorp Vault CA
description: How to configure a Smallstep ACME Registration Authority with Hashicorp Vault CA. 
---


A Registration Authority sits in front of a Certificate Authority (CA) and provides an authentication and authorization layer.
This guide will show you how to set up an ACME Registration Authority (RA) using `step-ca`, backed by a [Hashicorp Vault Certificate Authority][hvca] (HVCA) instance.

Note about Hashicorp Vault Certificate Authority:

> Vault's PKI secrets engine can dynamically generate X.509 certificates on demand. This allows services to acquire certificates without going through the usual manual process of generating a private key and Certificate Signing Request (CSR), submitting to a Certificate Authority (CA), and then waiting for the verification and signing process to complete.

[hvca (onprem)]: https://learn.hashicorp.com/tutorials/vault/pki-engine
[hvca (cloud)]: https://cloud.hashicorp.com/products/vault

## Requirements

* [`step-ca`](https://smallstep.com/docs/step-ca/installation)
* [Hashicorp Vault](https://learn.hashicorp.com/tutorials/vault/getting-started-deploy)
* [`jq`](https://stedolan.github.io/jq/download/) tool to parse JSON output.

When not specified, we run `vault` commands as `root`. A dedicated profile will be created after configuration.

## Configuration Guide

### 1. Start a Vault server and log into vault

For testing, you can run `vault server -dev` in a terminal window, and use an HTTP Vault address as shown here.
Note: in dev mode, you will lose your PKI when you exit the Vault server.

Now log into Vault:

```bash
export VAULT_ADDR='http://127.0.0.1:8200'
vault login token=xxxxx
```

Output:

```bash
Success! You are now authenticated. The token information displayed below
is already stored in the token helper. You do NOT need to run "vault login"
again. Future Vault requests will automatically use this token.

Key                  Value
---                  -----
token                hvs.VGBPeFkQtkGp5sDdHBug0Bge
token_accessor       kGo8ZgkOlrw9Fa1neEjDH52m
token_duration       ∞
token_renewable      false
token_policies       ["root"]
identity_policies    []
policies             ["root"]
```

### 2. Create your Root CA:

Now run: 

```bash
ROOT_CA_COMMON_NAME="Vault Root CA"
vault secrets enable pki
vault secrets tune -max-lease-ttl=87600h pki
vault write pki/root/generate/internal \
	common_name="$ROOT_CA_COMMON_NAME" \
	ttl=87600h
vault read -format=json pki/cert/$(vault list -format=json pki/certs | jq -r '.[0]') | jq -r .data.certificate > root_ca.crt
vault write pki/config/urls \
	issuing_certificates="$VAULT_ADDR/v1/pki/ca" \
	crl_distribution_points="$VAULT_ADDR/v1/pki/crl"
```

Your root CA is created,
and your root CA certificate PEM is saved in `root_ca.crt`.

### 3. Create your Intermediate CA:

Now let's create and sign the intermediate CA using the root CA.

```bash
INTERMEDIATE_CA_COMMON_NAME="Vault Intermediate CA"
vault secrets enable -path=pki_int1 pki
vault secrets tune -max-lease-ttl=43800h pki_int1
vault write -format=json pki_int1/intermediate/generate/internal \
	common_name="$INTERMEDIATE_CA_COMMON_NAME" \
	ttl=43800h  | jq -r .data.csr > int1.csr
vault write -format=json pki/root/sign-intermediate \
	csr=@int1.csr \
	format=pem_bundle \
	ttl=43800h | jq -r .data.certificate > int1.crt
cat int1.crt root_ca.crt > intermediate_ca.crt
vault write pki_int1/intermediate/set-signed \
	certificate=@intermediate_ca.crt
vault write pki_int1/config/urls \
	issuing_certificates="$VAULT_ADDR/v1/pki_int1/ca" \
	crl_distribution_points="$VAULT_ADDR/v1/pki_int1/crl"
```

Your intermediate CA is created,
and your root and intermediate CA PEM bundle is saved in `intermediate_ca.crt`.

### 3. Create Vault roles and policy

Now let's create Vault roles that your RA server will use to sign certificates.
To create these, run:

```bash
vault write pki_int1/roles/ec-role key_type=ec allow_any_name=true enforce_hostnames=false max_ttl=72h
vault write pki_int1/roles/rsa-role key_type=rsa allow_any_name=true enforce_hostnames=false max_ttl=72h
vault write pki_int1/roles/ed25519-role key_type=ed25519 allow_any_name=true enforce_hostnames=false max_ttl=72h
```

You'll also need policies for each role. Run:

```bash
echo 'path "pki_int1/sign/ec-role" {
    capabilities = ["create", "update"]
}
path "pki_int1/sign/rsa-role" {
    capabilities = ["create", "update"]
}
path "pki_int1/sign/ed25519-role" {
    capabilities = ["create", "update"]
}
path "pki_int/revoke" {
    capabilities = ["create", "update"]
}' > policy.hcl
vault policy write smallstep policy.hcl
```

### 4. Enable Vault authentication for your RA.

For the last part of our Vault setup, we need to configure Vault authentication.
Run:

```bash
vault auth enable -description="SmallStep RA AppRole" approle
vault write auth/approle/role/approle \
     bind_secret_id=true \
     local_secret_ids=false \
     secret_id_num_uses=0 \
     secret_id_ttl=0s \
     token_explicit_max_ttl=0s \
     token_max_ttl=0s \
     token_no_default_policy=false \
     token_num_uses=0 \
     token_period=0s \
     token_policies="smallstep" \
     token_ttl=0s \
     token_type=default
VAULT_ROLE_ID=$(vault read -field=role_id auth/approle/role/approle/role-id)
VAULT_SECRET_ID=$(vault write -field=secret_id -f auth/approle/role/approle/secret-id)
```

We'll need the `VAULT_ROLE_ID` and `VAULT_SECRET_ID` to configure our RA in the next step.

### 5. Configure the RA server.

In this section, we'll initialize a basic CA,
and then convert it into an RA.

First, run `step ca init` as described in [Getting Started](/docs/step-ca/getting-started).
Configure the DNS names, address, and JWK provisioner password.

Once the PKI is initialized, let's update `ca.json` to enable RA functionality:

```bash
VAULT_URI=http://127.0.0.1:8200
VAULT_CA_FINGERPRINT=$(step certificate fingerprint root_ca.crt)
cat <<< $(jq --arg vault_role_id "$VAULT_ROLE_ID" \
            --arg vault_secret_id "$VAULT_SECRET_ID" \
            --arg vault_uri "$VAULT_URI" \
            --arg vault_ca_fingerprint "$VAULT_CA_FINGERPRINT" \
             '(.authority += {
                "type": "vaultcas",
                "certificateAuthority": $vault_uri,
                "certificateAuthorityFingerprint": $vault_ca_fingerprint,
                "config": {
                          "pki": "pki_int1",
                          "pkiRoleRSA": "rsa-role",
                          "pkiRoleEC": "ec-role",
                          "pkiRoleEd25519": "ed25519-role",
                          "appRole": "approle",
                          "roleID": $vault_role_id,
                          "secretID": {
                                "fromString": $vault_secret_id
                          },
                          "IsWrappingToken": false
                }
})' $(step path)/config/ca.json) > $(step path)/config/ca.json
```

### 6. Start your RA server

```bash
$ step-ca $(step path)/config/ca.json
badger 2022/04/25 16:12:14 INFO: All 1 tables opened in 1ms
badger 2022/04/25 16:12:14 INFO: Replaying file id: 0 at offset: 9073
badger 2022/04/25 16:12:14 INFO: Replay took: 129.694µs
2022/04/25 16:12:14 Starting Smallstep CA/0.19.0 (linux/amd64)
2022/04/25 16:12:14 Documentation: https://u.step.sm/docs/ca
2022/04/25 16:12:14 Community Discord: https://u.step.sm/discord
2022/04/25 16:12:14 Current context: vault-test
2022/04/25 16:12:14 Config file: /home/awesome/.step/config/ca.json
2022/04/25 16:12:14 The primary server URL is https://localhost:4443
2022/04/25 16:12:14 Root certificates are available at https://localhost:4443/roots.pem
2022/04/25 16:12:14 X.509 Root Fingerprint: 2a0d4fe2b633301f02161bb667cf3d75939e32fee64642d73b16f76b7cdd1ea3
2022/04/25 16:12:14 Serving HTTPS on :4443 ...
```

At boot, `step-ca`'s will automatically send a CSR to Vault for the RA's internal TLS certificate.
Let's look up and verify the certificate:

```bash
CERT_PATH=pki_int1/cert/$(vault list -format=json pki_int1/certs | \
	 jq -r '.[0]' | \
 	 sed -e 's/:/-/g')
vault read -field=certificate $CERT_PATH | step certificate inspect
```

Output:

```
Certificate:
    Data:
        Version: 3 (0x2)
        Serial Number: 181870544504760955575180789200133046316293037181 (0x1fdb5b761da50e99dac7dd1ce11eda0c6a921c7d)
    Signature Algorithm: SHA256-RSA
        Issuer: CN=Vault Intermediate CA
        Validity
            Not Before: Apr 25 23:14:26 2022 UTC
... 
```

#### 7. Issue a test certificate

Now, in another window, let's bootstrap the `step` client with your RA and get a test certificate:

```bash
$ step ca bootstrap --ca-url https://localhost:4443 \
	 --fingerprint 2a0d4fe2b633301f02161bb667cf3d75939e32fee64642d73b16f76b7cdd1ea3
The root certificate has been saved in /home/awesome/.step/certs/root_ca.crt.
The authority configuration has been saved in /home/awesome/.step/config/defaults.json.

$ step ca certificate example.com example.crt example.key
✔ Provisioner: carl@smallstpe.com (JWK) [kid: oRxlIgpwI00GZUPZDMF-cASlh-sbmbdHS0pQOpNXszU]
Please enter the password to decrypt the provisioner key:
✔ CA: https://localhost:4443
✔ Certificate: example.crt
✔ Private Key: example.key
```

Hooray!

Finally, add an ACME provisioner to your RA:

```bash
step ca provisioner add --type acme acme
```

Now restart your RA server, and you will be able to certificates via the ACME protocol.
You can use `step`'s built-in ACME client support,
or use [any popular ACME client](/docs/tutorials/acme-protocol-acme-clients) to get certificates from your RA.

