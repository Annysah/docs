Now let's use `grpcurl` to test the server.
We'll pass the flag `-cacert` with our root CA certificate file.
Without this, the client will not trust the server, and the request will fail:

<CodeBlock language="shell-session" copyText="grpcurl -cacert ca.crt -d '{"name": "Smallstep"}' myserver.mycompany.net:443 helloworld.Greeter/SayHello">
{`$ grpcurl -cacert ca.crt \
-d '{"name": "Smallstep"}' myserver.mycompany.net:443 helloworld.Greeter/SayHello
{
  "message": "Hello Smallstep"
}`}
</CodeBlock>

Of course, typically you will want to write a gRPC client in Go, instead of using `grpcurl`. 
Like `grpcurl`, the client also needs to trust our root CA certificate to validate the server certificate.
Here's the code for a simple client:

```go
package main

import (
	"context"
	"crypto/x509"
	"log"
	"os"
	"time"

	"google.golang.org/grpc"
	"google.golang.org/grpc/credentials"
	"google.golang.org/grpc/examples/helloworld/helloworld"
)

func main() {
	// Address of the server to connect to
	address := "myserver.mycompany.net:443"
	// Path to the root CA
	caCert := "/home/step/certs/root_ca.crt"

	// Read the root CA and create the certificate pool to use
	b, err := os.ReadFile(caCert)
	if err != nil {
		log.Fatalf("error reading %s: %v", caCert, err)
	}
	pool := x509.NewCertPool()
	pool.AppendCertsFromPEM(b)

	// Connect to the remote host using our root CA
	conn, err := grpc.Dial(address,
		grpc.WithTransportCredentials(credentials.NewClientTLSFromCert(pool, "")),
	)
	if err != nil {
		log.Fatalf("did not connect: %v", err)
	}
	defer conn.Close()

	// Create the client and do a request
	client := helloworld.NewGreeterClient(conn)
	ctx, cancel := context.WithTimeout(context.Background(), time.Second)
	defer cancel()
	r, err := client.SayHello(ctx, &helloworld.HelloRequest{
		Name: "Smallstep",
	})
	if err != nil {
		log.Fatalf("could not greet: %v", err)
	}
	log.Printf("Greeting: %s", r.GetMessage())
}
```