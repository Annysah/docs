You'll also notice the above `Certificate` resource has an `issuerRef`
specifying a cert-manager `Issuer` resource named `my-ca`.
Before cert-manager knows how to use your CA
to issue and renew your certificate, we'll need to create
that `Issuer` resource and configure it to point
to your private ACME CA (or RA if you've configured one).
Create `my-ca-issuer.yaml` and fill in the CA URL with your own.
The `Issuer` will keep an account key in a Kubernetes secret
which is configurable here as well.

<DocConfig>
  {({ kubernetes }) => (
    <CodeBlock autoCopy language="yaml">
      {`apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: my-ca
spec:
  acme:
    # TODO add full URL path and configure for private acme (non-LE)
    server: https://my-ca-url.my-team.ca.smallstep.com
    privateKeySecretRef:
      name: my-ca-account-key
    solvers:
    - http01:
        ingress:
          class: ${kubernetes.ingressClass || 'nginx'}`}
    </CodeBlock>
  )}
</DocConfig>

Then apply:

```shell
kubectl apply -f my-ca-issuer.yaml
```

<DocConfig>
  {({ kubernetes }) => (
    <p>
      To verify that the requester of the certificate actually controls the DNS
      name specified in your ACME request (from <inlineCode>dnsName</inlineCode>{' '}
      in your <inlineCode>Certificate</inlineCode>), the ACME CA will send an
      HTTP challenge request to that DNS name and expects to receive particular
      response. For this reason, your Kubernetes cluster must have some HTTP
      ingress configured, and your DNS name must resolve to that ingress. In the
      above example, we assume your ingress has a class name{' '}
      <inlineCode>{kubernetes.ingressClass || 'nginx'}</inlineCode>, and
      cert-manager will automatically intercept ACME requests to that ingress to
      solve the HTTP01 ACME challenge sent by your CA. This effectively
      "authenticates" your ACME client with the CA, and the CA will then sign
      the certificate.
    </p>
  )}
</DocConfig>

<DocConfig>
  {({ name, server }) => (
    <p>
      If all went as expected now that both your{' '}
      <inlineCode>Certificate</inlineCode> and your{' '}
      <inlineCode>Issuer</inlineCode> are configured, cert-manager should have
      issued (or begun issuing) the certificate and created the{' '}
      <inlineCode>tls-{server.name}</inlineCode> secret with your certificate
      and private key. We'll reference this secret later when we configure{' '}
      {name} to use this certificate and private key for TLS.
    </p>
  )}
</DocConfig>

<Aside>
<p>
  If you prefer to use the DNS01 ACME challenge—which proves that you control
  the domain by updating a DNS record rather than resolving an HTTP request—your
  cert-manager <inlineCode>Issuer</inlineCode> can be configured as follows.
  This could be useful if you do not have any ingress to your cluster or
  otherwise are unable to resolve HTTP requests to your specified DNS name.
</p>

<DocConfig>
  {({ server, kubernetes }) => (
    <CodeBlock autoCopy language="yaml">
      {`apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: my-ca
spec:
  acme:
    server: https://my-ca-url.my-team.ca.smallstep.com
    privateKeySecretRef:
      name: tls-${server.name}
    solvers:
    - dns01:
        cloudDNS:
          project: my-project
          serviceAccountSecretRef:
            name: prod-clouddns-svc-acct-secret
            key: service-account.json`}
    </CodeBlock>
  )}
</DocConfig>

<p>
  The example above is configured for Google Cloud DNS, but you can refer to the{' '}
  <a href="https://cert-manager.io/docs/configuration/acme/dns01/">
    cert-manager DNS01 documentation
  </a>{' '}
  for specifics on how to configure your DNS provider. cert-manager will
  automatically handle updating your DNS zone to respond to ACME challenges from
  your CA.
</p>
</Aside>
