<DocConfig>
  {({ name }) => (
    <p>
      There are various approaches for configuring TLS certificate renewal in
      Kubernetes. For this tutorial, we will assume you are using{' '}
      <a href="https://helm.sh/">Helm</a> and will manage certificate renewal
      using the open source{' '}
      <a href="https://cert-manager.io/docs/">cert-manager</a> project. You may
      repurpose various pieces for your own configuration by following the
      cert-manager or {name} documentation.
    </p>
  )}
</DocConfig>

First, install cert-manager in your cluster with Helm:

```shell
helm repo add jetstack https://charts.jetstack.io
helm repo update
helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --set installCRDs=true
```

In cert-manager, a custom resource type `Certificate` represents
each TLS certififcate and specifies how to store it.

<DocConfig>
  {({ name, server }) => (
    <p>
      Create a new <inlineCode>Certificate</inlineCode> resource{' '}
      <inlineCode>{server.name}-certificate.yaml</inlineCode> for your {name}{' '}
      server. Make sure you specify the same DNS name configured above, and keep
      track of the Kuberentes secret name where cert-manager will store your
      certificate and private key.
    </p>
  )}
</DocConfig>

<DocConfig>
  {({ server }) => (
    <CodeBlock autoCopy language="yaml">
      {`apiVersion: cert-manager.io/v1
kind: Certificate
metadata:
  name: ${server.name}
spec:
  secretName: tls-${server.name}
  duration: 24h
  dnsNames:
    - ${server.dnsName}
  issuerRef:
    name: my-ca
    kind: Issuer
    group: cert-manager.io`}
    </CodeBlock>
  )}
</DocConfig>

Customize the `Certificate` name, `secretName`, and issuer name to suit your own naming style in your Kubernetes cluster, then apply it with `kubectl`.

<DocConfig>
  {({ server }) => (
    <CodeBlock autoCopy language="shell">
      {`kubectl apply -f ${server.name}-certificate.yaml`}
    </CodeBlock>
  )}
</DocConfig>

<DocConfig>
  {({ server }) => (
    <p>
      This configuration specifies that cert-manager should issue and renew a
      TLS certificate with the DNS name{' '}
      <inlineCode>{server.dnsName}</inlineCode> and store the certificate and
      private key in a Kubernetes secret named{' '}
      <inlineCode>tls-{server.name}</inlineCode>. The certificate is valid for
      24 hours, and cert-manager will automatically renew it before expiration
      and update the <inlineCode>tls-{server.name}</inlineCode> secret.
    </p>
  )}
</DocConfig>

You'll also notice the above `Certificate` resource has an `issuerRef` specifying
a cert-manager `Issuer` resource named `my-ca`. Before cert-manager knows how to use your CA to
issue and renew your certificate, we'll need to create and configure that `Issuer` resource
to point to your private ACME CA (or RA if you've configured one). Create `my-ca-issuer.yaml` and fill in the CA
URL with your own. Also, makes sure the secret reference matches the name you used in the certificate
resource.

<DocConfig>
  {({ server, kubernetes }) => (
    <CodeBlock autoCopy language="yaml">
      {`apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: my-ca
spec:
  acme:
    server: https://my-ca-url.my-team.ca.smallstep.com
    privateKeySecretRef:
      name: tls-${server.name}
    solvers:
    - http01:
        ingress:
          class: ${kubernetes.ingressClass || 'nginx'}`}
    </CodeBlock>
  )}
</DocConfig>

Then apply:

```shell
kubectl apply -f my-ca-issuer.yaml
```

<DocConfig>
  {({ kubernetes }) => (
    <p>
      To verify that the requester of the certificate actually controls the DNS
      name specified in your ACME request (from <inlineCode>dnsName</inlineCode>{' '}
      in your <inlineCode>Certificate</inlineCode>), the ACME CA will send an
      HTTP challenge request to that DNS name and expects to receive particular
      response. For this reason, your Kubernetes cluster must have some HTTP
      ingress configured, and your DNS name must resolve to that ingress. In the
      above example, we assume your ingress has a class name{' '}
      <inlineCode>{kubernetes.ingressClass || 'nginx'}</inlineCode>, and
      cert-manager will automatically intercept ACME requests to that ingress to
      solve the HTTP01 ACME challenge sent by your CA. This effectively
      "authenticates" your ACME client with the CA, and the CA will then sign
      the certificate.
    </p>
  )}
</DocConfig>

<DocConfig>
  {({ name, server }) => (
    <p>
      If all went as expected now that both your{' '}
      <inlineCode>Certificate</inlineCode> and your{' '}
      <inlineCode>Issuer</inlineCode> are configured, cert-manager should have
      issued (or begun issuing) the certificate and created the{' '}
      <inlineCode>tls-{server.name}</inlineCode> secret with your certificate
      and private key. We'll reference this secret later when we configure{' '}
      {name} to use this certificate and private key for TLS.
    </p>
  )}
</DocConfig>

<Aside>
<p>
If you prefer to use the DNS01 ACME challenge—which proves that you control the domain
by updating a DNS record rather than resoling an HTTP request—your cert-manager <inlineCode>Issuer</inlineCode> can be configured as follows. This could be
useful if you do not have any ingress to your cluster or otherwise are unable to resolve HTTP requests
to your specified DNS name.
</p>

<DocConfig>
  {({ server, kubernetes }) => (
    <CodeBlock autoCopy language="yaml">
      {`apiVersion: cert-manager.io/v1
kind: Issuer
metadata:
  name: my-ca
spec:
  acme:
    server: https://my-ca-url.my-team.ca.smallstep.com
    privateKeySecretRef:
      name: tls-${server.name}
    solvers:
    - dns01:
        cloudDNS:
          project: my-project
          serviceAccountSecretRef:
            name: prod-clouddns-svc-acct-secret
            key: service-account.json`}
    </CodeBlock>
  )}
</DocConfig>

<p>
The example above is configured for Google Cloud DNS,
but you can refer to the{' '}
<a href="https://cert-manager.io/docs/configuration/acme/dns01/">cert-manager DNS01 documentation</a>{' '}
for specifics on how to configure your DNS provider.
cert-manager will automatically handle updating your DNS zone
to respond to ACME challenges from your CA.
</p>
</Aside>
